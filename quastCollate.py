#!/usr/bin/env python

import argparse
import sys
from Bio import SeqIO
import os
import getopt
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

#######################################################################
##This script collates major summary statistics from the report.txt  
##file generated by Quast.
#######################################################################


class FullPaths(argparse.Action):
    """Expand user- and relative-paths"""
    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest,
            os.path.abspath(os.path.expanduser(values)))

def is_file(filename):
    """Checks if a file exists"""
    if not os.path.isfile(filename):
        msg = "{0} is not a file".format(filename)
        raise argparse.ArgumentTypeError(msg)
    else:
        return filename

def get_arguments(): 
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="Collate summary info from multiple bamqc runs")
    parser.add_argument('-i', '--inputFile',
        help = 'file containing paths to bamqc results that are to be collated', 
        type = is_file,
        required = True)
    parser.add_argument('-o', '--outputFile',
        help = 'name of output file,',
        required = True)
    return parser.parse_args()

def make_inputList():
    inputList = []
    with open(args.inputFile, 'r') as infile:
        for line in infile:
            line = line.strip()
            inputList.append(line)
    return inputList

def make_dict(inputList):
    d = {}
    """for every file in input, extract parameters from the genome_results.txt file"""
    for f in inputList:
        with open(f, 'r') as infile:
            for i, line in enumerate(infile):
                line = line.strip()
                entries = line.split()
                if i > 1:
                    if i == 2:
                        sample = entries[-1].split(".")[0]
                        print sample
                        d[sample] ={}
                    else:
                        value = entries[-1]
                        key = "_".join(entries[0:-1]).strip("#").strip("_")
                        d[sample][key] = value
    return d

def write_file(d):
    with open(args.outputFile, 'w') as outfile:
        outfile.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' %
            ("Sample", "meanCov", "stdCov", "meanMQ", "perMapped", 
            "perGen10X", "perGen15X", "perGen20X", "perGen30X", "dupRate",
            "errRate", "misMat", "numIns", "insPer", "numDel", "delPer", 
            "homInd", "meanIns", "medIns", "stdIns", "GCper", "A", "C", "G",
            "T", "N", "indels"))
        for key in d:
            GC = d[key]['GC_(%)']
            perGen = d[key]['Genome_fraction_(%)']
            N = (float(d[key]["N's_per_100_kbp"])/100000)*int(d[key]['Total_length'])
            misMat = str((float(d[key]['mismatches_per_100_kbp'])/100000)*int(d[key]['Total_length']))
            ind = str((float(d[key]['indels_per_100_kbp'])/100000)*int(d[key]['Total_length']))
            dup = str(float(d[key]['Duplication_ratio'])*100)
            outfile.write('%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n' %
                (key, "NA", "NA", "NA",
                "NA", perGen, 
                perGen, perGen, 
                perGen, dup, "NA",
                misMat, "NA", "NA",
                "NA", "NA", "NA",
                "NA", "NA", "NA", 
                GC, "NA", "NA", "NA", 
                "NA", N, ind))

args = get_arguments()
inputList = make_inputList()
d = make_dict(inputList)
write_file(d)
